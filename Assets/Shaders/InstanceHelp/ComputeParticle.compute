// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel PaintMain

struct MeshProperties
{
    float4x4 mat;
    float2 UV; //UV
    float4 color;
};

RWStructuredBuffer<MeshProperties> _Properties;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
Texture2D<float4> _PaintBuffer; //read only heightmap ! (paintBuffer)
Texture2D<float4> _NormalsBuffer; //read only viewNormals map
Texture2D<float> _DepthBuffer;
Texture2D<float4> _ColorBuffer;
RWTexture2D<float4> _SeenBuffer;
RWTexture2D<float4> _Result;
float4x4 _invViewMat;
float4x4 _invProjectionMatrix;
float _CameraNearPlane;
float _CameraFarPlane;

static const int _directions[8] = { -1, 0, 1, 0, 0, 1, 0, -1 };

float3x3 NormalRotationMatrix(float3 v1, float3 v2) //-- v1 = up vector and v2 the normal that i want for my vertices
{
    float3 axis = cross(v1, v2);
 
    float cosA = dot(v1, v2);
    float k = 1.0f / (1.0f + cosA);
 
    float3x3 result =
                    float3x3(
                        (axis.x * axis.x * k) + cosA,
                        (axis.y * axis.x * k) - axis.z,
                        (axis.z * axis.x * k) + axis.y,
                        (axis.x * axis.y * k) + axis.z,
                        (axis.y * axis.y * k) + cosA,
                        (axis.z * axis.y * k) - axis.x,
                        (axis.x * axis.z * k) - axis.y,
                        (axis.y * axis.z * k) + axis.x,
                        (axis.z * axis.z * k) + cosA
                        );
 
    return result;
}

float4x4 Rot3ToMat4(float3x3 rot)
{
    return float4x4(
                rot[0][0],
                rot[0][1],
                rot[0][2],
                0,
                rot[1][0],
                rot[1][1],
                rot[1][2],
                0,
                rot[2][0],
                rot[2][1],
                rot[2][2],
                0,
                0,
                0,
                0,
                1
    );
}

float LinearDepth(float z)
{
    //float near = _CameraNearPlane;
    //float far = _CameraFarPlane;
    //return (2.0 * near * far) / (far + near - z * (far - near));
    
    float near = _CameraNearPlane;
    float far = _CameraFarPlane;
    //return (2.0 * near * far) / (far + near - z * (far - near));
    float x_i = 1.0f;
    float y_i = 1.0f;
    float z_i = 1.0f;
    float w_i = 1.0f;
    //float x, y, z, w = 1.0f;
    ////#if UNITY_REVERSED_Z
    ////x = -1 + far / near;
    ////y = 1;
    ////z = x / far;
    ////w = 1 / far;
    
    ////#else
    x_i = 1.0f - (far / near);
    y_i = (far / near);
    z_i = x_i / far;
    w_i = y_i / far;
    //#endif
    
    //x_i = -1.0f + (far / near);
    //y_i = 1.0f;
    //z_i = x_i / far;
    //w_i = 1.0f / far;
    
    float4 _ZBufferParams = float4(x_i, y_i, z_i, w_i);
    //float4 _ZBufferParams = float4(1, 1, 1, 1);
    return 1.0f / (_ZBufferParams.z * z + _ZBufferParams.w);
    //return 1.0;
    
//    float near = _CameraNearPlane;
//    float far = _CameraFarPlane;
//    //float z_ndc = z * 2.0 - 1.0; // Convert from [0, 1] to [-1, 1]
//    float z_ndc = z;
//    float z_eye = 2.0 * near * far / (far + near - z_ndc * (far - near)); // Convert from [-1, 1] to eye space
//    return z_eye;
}



[numthreads(64,1,1)]
void PaintMain (uint3 id : SV_DispatchThreadID)
{
    float2 UV = _Properties[id.x].UV;
    UV.x *= 1280;
    UV.y *= 720;
    //scene buffer is 96 x 54
    [unroll] for (int i = 0; i < 40; i++)
    {
        float v_cur = _PaintBuffer[UV.xy].r;
        float2 dir_to_go = float2(0, 0);
        for (int j = 0; j < 4; j++)
        {
            float2 disp = float2(_directions[j * 2], _directions[j * 2 + 1]);
            float2 neighbor = disp + UV;
            neighbor.x = max(0, neighbor.x);
            neighbor.x = min(1280, neighbor.x);
            neighbor.y = max(0, neighbor.y);
            neighbor.y = min(720, neighbor.y);
            disp = neighbor - UV;
            
            float v_n = _PaintBuffer[neighbor.xy].r;
            
            if (v_n > v_cur)
            {
                dir_to_go = disp;
            }
        }
        UV += dir_to_go;
    }    
    
    float2 Seen_UV = float2(UV.x * 96.0f / 1280.0f, UV.y * 54.0f / 720.0f);
    if (_SeenBuffer[Seen_UV.xy].r != 0)
    {
        return;
    }

    float4 height = _PaintBuffer[UV.xy];
    
    
    
    //Rotation Logic//
    float4 normal = _NormalsBuffer[UV.xy];
    normal = normalize(normal); //0 to 1
    float3 up = float3(0, 0, 1);
    //normal.z *= -1;
    float3x3 RM = NormalRotationMatrix(up.xyz, normal.xyz);
    float4x4 newMat = Rot3ToMat4(RM);
    
    float4x4 cameraRotation = _invViewMat;
    cameraRotation[0][3] = 0;
    cameraRotation[1][3] = 0;
    cameraRotation[2][3] = 0;
    
    newMat = mul(cameraRotation, newMat);
    //Rotation Logic//
    
    //Depth Logic//
    float sceneZ = 1.0f - _DepthBuffer[UV.xy].r;

    float2 UV_01 = float2(UV.x / 1280, UV.y / 720);
    float4 clipSpacePosition = float4(UV_01 * 2 - 1, sceneZ * 2.0 - 1.0, 1.0);
    
    // Transform to view space
    float4 viewSpacePosition = mul(_invProjectionMatrix, clipSpacePosition);
    viewSpacePosition /= viewSpacePosition.w;
    //viewSpacePosition.xyz += 1.0f * normal;
    
    float3 disp = 0.04f * normal.xyz;
    
    viewSpacePosition.x += disp.x;
    viewSpacePosition.y += disp.y;
    viewSpacePosition.z += disp.z;
    
    
    // Transform to world space
    float4 worldSpacePosition = mul(_invViewMat, viewSpacePosition);
    //
    if (height.r > 0 && sceneZ != 0)
    {
        _SeenBuffer[Seen_UV.xy] = float4(1, 1, 1, 1);
        float3 rawPos = worldSpacePosition.xyz;
        
        newMat[0][3] = rawPos.x;
        newMat[1][3] = rawPos.y;
        newMat[2][3] = rawPos.z;
    }
    else
    {
        newMat[0][3] = -100;
        newMat[1][3] = -100;
    }
    
    
    //
    _Properties[id.x].mat = newMat;
    _Properties[id.x].color = _ColorBuffer[UV.xy];
}

//float LinearDepth(float z)
//{
//    float near = _CameraNearPlane;
//    float far = _CameraFarPlane;
//    //return (2.0 * near * far) / (far + near - z * (far - near));
//    float x, y, z, w;
//    //#if UNITY_REVERSED_Z
//    //x = -1 + far / near;
//    //y = 1;
//    //z = x / far;
//    //w = 1 / far;
    
//    //#else
//    x = 1 - far / near;
//    y = far / near;
//    z = x / far;
//    w = y / far;
//    //#endif
    
//    float4 _ZBufferParams = float4(x, y, z, w);
//    return 1.0 / (_ZBufferParams.z * z + _ZBufferParams.w);
//}




 /*
    //if (_SeenBuffer[UV.xy])
    //return;
    
    //float4x1 newWorldOrigin = _invViewMat * float4(0, 0, -1, 1);
    float4 newOrigin = mul(_invViewMat, float4(0, 0, -1, 1));
  
    float4 height = _PaintBuffer[UV.xy];
    
    float4 normal = _NormalsBuffer[UV.xy];
    normal = normalize(normal);
    float3 up = float3(0, 0, 1);
    //normal.z *= -1;
    float3x3 RM = NormalRotationMatrix(up.xyz, normal.xyz);
    
    float4x4 newMat = Rot3ToMat4(RM);
    
    float sceneZ = 1;
    
    sceneZ = _DepthBuffer[UV.xy].r;
    
    float breh = 0.01f;
    
    if (height.r > 0 && sceneZ != 0)
    {
        _SeenBuffer[Seen_UV.xy] = float4(1, 1, 1, 1);
        _Result[UV.xy] = float4(1, 1, 1, 1);
        
        float3 rawPos = float3(UV.x * breh, UV.y * breh, (1.0f - pow(max((1.0f - sceneZ), 0.0f), 60.0f)) * 10.0f);
        //newMat[0][3] = UV.x * breh; 
        //newMat[1][3] = UV.y * breh;
        //newMat[2][3] = (1.0f - pow(max((1.0f - sceneZ), 0.0f), 60.0f)) * 10.0f;
        
        //rawPos += newOrigin.xyz;
        
        
        // Convert UV and depth to NDC
        float4 clipSpacePosition = float4(uv * 2 - 1, depth, 1.0);

    // Transform to view space
        float4 viewSpacePosition = mul(_InvProjectionMatrix, clipSpacePosition);
        viewSpacePosition /= viewSpacePosition.w;

    // Transform to world space
        float4 worldSpacePosition = mul(_InvViewMatrix, viewSpacePosition);

    // Write to output texture
        _ResultTexture[id.xy] = worldSpacePosition;
        
        newMat[0][3] = rawPos.x;
        newMat[1][3] = rawPos.y;
        newMat[2][3] = rawPos.z;
    }
    else
    {
        newMat[0][3] = -100;
        newMat[1][3] = -100;
    }
*/
    //


























    //_Result[]
    //float4x4 mat = _Properties[id.x].mat;
    //// In a transform matrix, the position (translation) vector is the last column.
    //float3 position = float3(mat[0][3], mat[1][3], mat[2][3]);
    
    
    //most important are x, and y
    
    //Consider x and y as UV coordinates!
    
    //UV = (x, y)
    
    //Read _PaintBuffer to get slope at (x, y)
    //use just the 4 cardinal directions- that should be enough.
    //Move in the direction of greatest change
    
    /////////////// PHYSICS SIM (probably like 5 passes) /////////////////////
    //float dist = distance(position, _PusherPosition);
    
    //// Scale and reverse distance so that we get a value which fades as it gets further away.
    //// Max distance is 5.0.
    //dist = 20.0 - clamp(dist, 0.0, 20.0);

    //// Get the vector from the pusher to the position, and scale it.
    //float3 push = normalize(position - _PusherPosition) * dist;
    ////push = float3(0.5, 0.5, 0.5);
    //// Create a new translation matrix which represents a move in a direction.
    //float4x4 translation = float4x4(
    //    1, 0, 0, push.x,
    //    0, 1, 0, push.y,
    //    0, 0, 1, push.z,
    //    0, 0, 0, 1
    //);
    
    /////////////// PHYSICS SIM (probably like 5 passes) /////////////////////

    // Apply translation to existing matrix, which will be read in the shader.
    //_Properties[id.x].mat = mul(translation, mat);
    
    // Apply physics sim/gravity sim on particle!
    //_Properties[id.x].mat = mul(translation, mat);
    //if texture at new point is not white ... change this position to off screen (e.g. -10, -10, 0)
    //or ... if the seen texture (which will be a black and white bit map for identifying which pixels have already been selected ...